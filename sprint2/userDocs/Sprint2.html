<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0114)file:///C:/Users/Davide/Desktop/issLab2022/it.unibo.issLabStart/userDocs/Dispense/html/_static/templateToFill.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    

   
<title>Waste Service SPRINT 2</title></head>
    
<body>
<div id="top">
<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
<div class="remark">
Progetto finale del corso di studio Ingegneria dei sistemi software M, Laurea Magistrale Università di Bologna. (SPRINT 2)
</div>

<h2>Sprint 1 results</h2>
<div class="remark">
Di seguito &eacute riportato il risultato finale ottenuto al termine dello Sprint 1:<br>
<img src="./img_Sprint2/sintesiFinale_Sprint1.png" alt="RF2" width="90%" height="90%"><br>
CODICE: <a href="../../sprint1/src/analisiProblema_v4.qak">modello eseguibile</a><br>
TEST: <a href="../../sprint1/test/it/unibo/TestApplSprint1.java">Test plan</a><br><br>

</div>
 
 
<h2>Requirements</h2>
<div class="remark">
Per la parte di requisiti si veda la <a href="../../sprint1/userDocs/Sprint1_v2.html#requisiti">sezione Requirement dello Sprint 1</a>

</div>

 

<h2>Requirement analysis</h2>
<div class="remark">
<h3>PUNTI APERTI:</h3>
<ul>
 <li>il Service-manager &eacute l'utilizzatore del SONAR e lo utilizza per bloccare il robot?<br>
 S&iacute, viene usato come una sorta di pulsante.</li>
 <li>Il LED &eacute accesso quando il TROLLEY &eacute STOPPED, inteso quando fermato a causa del SONAR oppure anche davanti ai box per scaricare?<br>
 Per stato STOPPED si intende quando il TROLLEY &eacute fermo a causa del SONAR</li>
 <li>Il WASTE_SERVICE deve pilotare il LED o pu&oacute delegare un'altra entit&aacute?<br>
 Il WASTE_SERVICE d&aacute il comando questo poi pu&oacute essere delegato ad un'altra entit&aacute </li>
 <li>Lo stato di LED e TROLLEY &eacute un'informazione di fondamentale importanza per l'applicazione oppure ci possono essere delle imprecisioni?<br>
 Non sono informazioni fondamentali per il sistema, possono esserci delle imprecisioni</li> 
 <li>&Eacute possibile introdurre un'entit&aacute aggiuntiva per processare i dati provenienti dal SONAR?<br>
 L'importante &eacute che ci siano le entit&aacute richieste dai requisiti, delle entit&aacute aggiuntive non sono un problema</li>
 <li>Come trattare lo stato STOPPED del TROLLEY (fermo subito oppure finisce azione e si ferma)?<br>
 Il TROLLEY si deve fermare subito</li>
</ul>
 <br><br>
Per le considerazioni fatte su Requisiti funzionali e Requisiti non funzionali si vedano
i paragrafi dedicati nello  <a href="../../sprint1/userDocs/Sprint1_v2.html#analisi_requisiti">Sprint 1</a><br><br>

<h3>COMPONENTI A DISPOSIZIONE</h3>
Viene fortinto il software per l'utilizzo del <a href="https://github.com/anatali/issLab2022/tree/main/unibo.sonarqak22">SONAR</a> e del <a href="https://github.com/anatali/issLab2022/tree/main/unibo.ledqak22">LED</a>.<br>
<h3>PROBLEMATICHE RF2</h3>
In questo Sprint ci concentreremo solamente sul RF2.
<ul>
<li><h4>STATO TROLLEY</h4>
Chi &eacute il responsabile dello stato del TROLLEY (HOME, Movimento, Stopped).</li>
<li><h4>TRATTAMENTO DISTANZA</h4>
Chi &eacute il responsabile del processamento dei valori di distanza rilevati del SONAR. 
</li>
<li><h4>COMANDO STOP/RESUME</h4>
Il TROLLEY deve ricevere un comando di stop/resume.</li>
<li><h4>COMANDO ON/OFF/BLINK</h4>
Il WASTE_SERVICE deve inviare un comando on/off/blink al LED.</li>
</ul>

</div>

<h2>Problem analysis</h2>
<div class="remark">
<h3> PROBLEMATICHE RF2 EVIDENZIATE DURANTE L'ANALISI DEI REQUISITI</h3>
<h4> STATO TROLLEY </h4>
Attualmente, nel modello realizzato nello Sprint 1, lo stato del
TROLLEY &eacute noto a due entit&aacute, ossia il TROLLEY stesso e il WASTE_SERVICE. Con l'introduzione del RF2,
per&oacute bisogna considerare un nuovo stato in cui il TROLLEY si pu&oacute trovare, lo stato STOPPED.
La problematica che sorge &eacute chi &eacute a conoscenza dello stato reale del TROLLEY e quindi chi andare ad interrogare
per conoscerlo. In particolare:
<ul>
	<li>TROLLEY: &eacute sempre a conoscenza dello stato in cui si trova. D'altro canto per&oacute in questo caso il TROLLEY deve comunicare il suo stato agli interessati (LED). 
		In base a come viene effettuata la comunicazione il TROLLEY pu&oacute perdere la caratteristica di essere un attuatore e pu&oacute non essere rispettato
		il requisito che il WASTE_SERVICE deve pilotare il LED ("Durante questa attività il WasteService fa lampeggiare il Led.").</li>
	<li>WASTE_SERVICE: nel modello attuale esso pu&oacute inferire lo stato in cui si trova il TROLLEY in base allo stato in cui esso stesso si trova. Aggiungendo lo 
		stato STOPPED per&oacute, &eacute necessario che il WASTE_SERVICE riceva le informazioni di quando fermare e riavviare il TROLLEY sulla base delle distanze rilevate dal SONAR.</li>
</ul>

<h5>CONCLUSIONI</h5>
Visto che il WASTE_SERVICE &eacute il responsabile del comportamento che il LED deve assumenre in ogni istante, &eacute consigliato che anche le informazioni
che riguardono lo stato del TROLLEY siano mantenute e aggiornate dal WASTE_SERVICE stesso. In questo modo il TROLLEY non deve neanche 
occuparsi della gestione del LED, mantenendo la caratteristica di attuatore.<br>


<h4> TRATTAMENTO DISTANZA </h4>
Abbiamo a disposizione diverse implementazioni del SONAR fornite dal committente (<a href="https://github.com/anatali/issLab2022/blob/main/unibo.actor22/test/unibo/actor22/events/SonarActor22.java">Sonar</a> e <a href="https://github.com/anatali/issLab2022/tree/main/unibo.sonarqak22">SonarObservable</a> ). 
Dovendo lavorare con un flusso continuo di informazioni (sequenza di distanze rilevate) non è consigliato interagire con il SONAR mediante dispatch oppure con uno schema request-response.<br>
Perci&oacute si consiglia l'utilizzo del SonarObservable che emette eventi, i quali possono essere rilevanti per entit&aacute diverse:
<ol>
	<li>TROLLEY:<br>
	<ul>
		<li>PRO: il TROLLEY gestisce autonomamente il proprio stato in base alle indicazioni del SONAR. </li>
		<li>CONTRO: viene complicata la struttura del TROLLEY, in quanto dovr&aacute processare gli eventi emessi dal SONAR, perdendo cos&iacute la caratteristica di attuatore.</li>
	
	</ul></li>
	<li>WASTE_SERVICE:<br>
	<ul>
		<li>PRO: il WASTE_SERVICE diventa il fulcro del sistema in quanto si incarica di processare tutte le informazioni provenienti dagli altri componenti</li>
		<li>CONTRO: si aggiunge un ulteriore compito al WASTE_SERVICE complicando la sua realizzazione. Inoltre il WASTE_SERVICE deve anche comunicare con il TROLLEY per effettuare l'eventuale sospensione e riavvio.</li>
	</ul></li>
	<li>ENTIT&Aacute DEDICATA : con entit&aacute dedicata si intende sia una nuova componente ma anche
	una pipeline di attori che filtra il contenuto degli eventi emessi dal SONAR<br>
	<ul>
		<li>PRO: si utilizza un'entit&aacute dedicata per processare le informazioni provenienti dal SONAR e comunicarle solo quando sono rilevanti agli interessati sotto forma di dispatch, evento o request-response (allarme), andando a soddisfare il principio di "Singola Responasbilit&aacute" e facilitando la realizzazione del sistema, visto che riduciamo i compiti del WASTE_SERVICE.</li>
		<li>CONTRO: si aggiunge un'ulteriore entit&aacute .</li>
	</ul></li>
</ol>
<h5>CONCLUSIONI</h5>
In caso di entit&aacute dedicata, la comunicazione delle informazioni rilevanti &eacute consigliato che 
avvenga mediante un dispatch in modo tale da assicurare la ricezione del messaggio e riducendo al minimo il numero di interazioni.<br>

<h4> COMANDO STOP/RESUME </h4>
Il TROLLEY in base alla distanza rilevata dal SONAR deve eventualmente mutare il suo stato (Movimento -> Stopped e viceversa).<br>
La comunicazione di ci&oacute &eacute influenzata dalle scelte che verranno fatte nelle problematiche affrontate in precedenza:
<ol>
	<li>GESTITO DAL TROLLEY:<br>
	Il TROLLEY riceve gli eventi emessi dal SONAR direttamente (TRATTAMENTO DISTANZA punto 1) e in base ad essi commuta il suo stato (comando interno).
	<ul>
		<li>PRO: disccoppiamento, il TROLLEY gestisce autonomamente il proprio stato in base alle indicazioni ricevute. </li>
		<li>CONTRO: viene complicata la struttura del TROLLEY, in quanto esso deve essere sensibile agli eventi del SONAR ed inoltre deve possedere logica di business,
			perdendo cos&iacute la caratteristica di attuatore.</li>
	
	</ul></li>
	<li>COMANDO INVIATO DA ENTIT&Aacute TERZA:<br>
	L'entit&aacute terza processa le informazioni provenienti dal SONAR e in base ad esse comunica direttamente al TROLLEY o tramite il WASTE_SERVICE il comando da effettuare attraverso una delle tre
	forme di comunicazioni affrontate fino ad ora.
	<ul>
		<li>PRO: si utilizza un'entit&aacute dedicata per processare le informazioni provenienti dal SONAR e comunicarle solo quando sono rilevanti, andando a soddisfare il principio di "Singola Responasbilit&aacute". </li>
		<li>CONTRO: si aggiunge un'ulteriore entit&aacute. </li>
	</ul></li>
	<li>COMANDO INVIATO DAL WASTE_SERVICE:<br>
	Il WASTE_SERVICE riceve gli eventi direttamente dal SONAR o l'allarme dall'entit&aacute terza e comunica al TROLLEY il comando da effettuare mediante una delle tre forme (dispatch, evento, request-response)
	viste fino ad ora. I PRO e i CONTRO delle tre forme non verranno analizzate nel dettaglio in quanto gi&aacute studiate ampiamente nello Sprint precedente.
	<ul>
		<li>PRO: il WASTE_SERVICE diventa il controllore dell'intero sistema essendo a conoscenza dello stato di ogni componente.</li>
		<li>CONTRO: si aggiunge un ulteriore compito al WASTE_SERVICE complicando la sua realizzazione</li>
	</ul></li>
</ol>
<h5>CONCLUSIONI</h5>
Visto che non vi sono particolari richieste, si sconsiglia di non far gestire tale comando direttamente al TROLLEY.<br>

<h4>DOVE MEMORIZZARE LO STATO IN CUI SI STOPPA IL TROLLEY</h4>
Visto che con l'aggiunta del RF2 &eacute necessario gestire la fermata e la ripartenza del TROLLEY, &eacute fondamentale
essere a conoscenza dello stato in cui si trovava il TROLLEY prima di ricevere il comando di stop, per garantire la corretta ripartenza
ed eseguire la giusta sequenza di operazioni che compone un'azione di deposito (Pickup, Trasferimento, Deposito).<br>
Innanzitutto bisogna distinguere due tipologie di stati in cui si pu&oacute trovare il TROLLEY:
<ul>
	<li> Stato in cui sta eseguendo un MOVIMENTO: Pickup (considerando solo lo spostamento all'INDOOR [leggere dopo]), Trasferimento 
		e Ritorno_home.</li>
	<li>Stato STATICI: Home, Pickup (considerando la parte di prelievo) e Deposito.</li>
</ul>
Dopo questa osservazione, notiamo che lo stato denominato "pickup" nei modelli eseguibili realizzati nello Sprint 1, in realt&aacute
incorpora in s&eacute due stati differenti che possiamo chiamare "go_indoor" e "pickup". Per questo riteniamo opportuno scinderlo, in
modo tale da facilitare l'introduzione delle nuove funzionalit&aacute. <br>
In uno stato "di MOVIMENTO" vi &eacute la necessit&aacute di comunicare con il pathexecutor di interrompere le azioni che stata svolegendo e di memorizzare quelle rimanenti per effettuarle 
nella fase di resume. Questa complicazione invece non &eacute presente negli stati STATICI dove &eacute sufficiente "ricordarsi", in fase di resume, solo lo stato in cui ci trovavamo.<br>
In base a quanto appena detto &eacute fondamentale, in fase di resume, sapere lo stato in cui siamo stati bloccati. Ci&oacute pu&oacute essere fatto 
da due entit&aacute differenti:
<ul>
	<li>TROLLEY: 
	<ul>
		<li>PRO: vengono ridotti i compiti del WASTE_SERVICE in quanto non deve memorizzare lo stato in cui si trova il TROLLEY e si occupa solo di effettuare il resume. </li>
		<li>CONTRO: con alte probabilit&aacute il WASTE_SERVICE deve sapere in tutti i modi lo stato in cui si trova il TROLLEY e quindi memorizzarsi comunque questa informazione </li>
	</ul></li>
	<li>WASTE_SERVICE: 
	<ul>
		<li>PRO: deve conoscere lo stato del TROLLEY per regolare il comportamento degli altri componenti (LED) </li>
		<li>CONTRO: aumenta il carico di lavoro del WASTE_SERVICE ed &eacute necessario, in fase di resume, comunicarlo al TROLLEY</li>
	</ul></li>
</ul> 

<h4>COME MEMORIZZARE LO STATO IN CUI SI STOPPA IL TROLLEY</h4>
L'informazione riguardante lo stato in cui si trova il TROLLEY pu&oacute essere memorizzata in vari modi:
<ul>
	<li>DUPLICAZIONE DEGLI STATI PRESENTI: per ogni stato presente nella FSM viene introdotto il corrispondente stato STOPPED, in 
		questo modo, all'arrivo di una resume, &eacute semplice stabilire da quale stato ripartire.</li>
	<li>UTILIZZO DI UNA VARIABILE: viene usata una variabile interna per memorizzare lo stato in cui &eacute avvenuto
		lo stop, in questo modo si evita la prolificazione di stati, "alleggerendo" la struttura della FSM.</li>
	<li>INTERRUPT (<a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/RobotCleaner.html#stop-resume-un-nuovo-abstraction-gap">link</a>): 
		modellare per il linguaggio QAK un meccanismo di chiamata a procedura, in maniera tale da memorizzarsi lo stato in cui ci trovavamo prima del comando di stop
		e poterlo ripristinare correttamente dopo l'arrivo di una resume.</li>
</ul>
<h5>CONCLUSIONI</h5>
La soluzione pi&uacute "elegante", in quanto riduce l'abstaction gap, sarebbe quella di utilizzare gli interrupt, ma questa richiederebbe molto tempo per realizzarla.<br>
Perci&oacute si consiglia di gestire lo stato lato WASTE_SERVICE, in quanto deve comunque mantenerlo per pilotare il LED, mentre per quanto concerne la
modalit&aacute di implementazione si lascia potere decisionale al progettista.<br>

<h4>DA QUALE STATO RIAVVIARE IL TROLLEY</h4>
All'arrivo del comando resume vi possono essere due alternative riguardanti lo stato da cui ripartire:
<ul>
	<li>Stato ATTUALE: si riparte dallo stato in cui si trovava il TROLLEY al momento dello stop, in questo caso bisogna fare 
		attenzione alle azioni da compiere al momento della resume.</li>
	<li>Stato SUCCESSIVO: al momento della resume vengono effettuate le "azioni mancanti" e si riparte dallo stato successivo,
		&eacute necessario fare attenzione alle risposte che devono essere inviate al WASTE_SERVICE in fase di riavvio
		visto che la comunucazione tra queste due entit&aacute &eacute stata realizzata con uno schema request-response.</li>
</ul>
<h5>CONCLUSIONI</h5>
Non essendoci richieste specifiche dal committente, si lascia libert&aacute di scelta al progettista, optando per la soluzione
pi&uacute facile e rapida da realizzare.<br>

<h4> COMANDO ON/OFF/BLINK </h4>
Il LED deve ricevere un comando per commutare il proprio stato, esso pu&oacute essere inviato da diverse entit&aacute
che devono essere a conoscenza dello stato del TROLLEY in quanto il comportamento del LED dipende da esso. I casi possono essere i seguenti:
<ul>
	<li> LED pilotato dal TROLLEY: 
	<ul>
		<li>PRO: il TROLLEY conosce sempre il suo stato, non &eacute necessario condividerlo con nessun altra entit&aacute. </li>
		<li>CONTRO: il TROLLEY non &eacute pi&uacute un attuatore e si rischia di non soddisfare il requisito dato dal commitente ("Durante questa attività il WasteService fa lampeggiare il Led.").</li>
	</ul></li>
	<li> LED pilotato dal WASTE_SERVICE: 
	<ul>
		<li>PRO: il TROLLEY resta un attuatore e il WASTE_SERVICE funge da controller dell'intero sistema. </li>
		<li>CONTRO: il WASTE_SERVICE deve mantenere lo stato del TROLLEY anche quando esso &eacute nello stato STOPPED.</li>
	</ul></li>
</ul>
<h5>CONCLUSIONI</h5>
Per rispettare i requisiti dati dal committente &eacute necessario che il WASTE_SERVICE sia il responsabile del comportamento del LED e quindi
sia esso a prendere le decisioni che lo riguardano (invio del comando).<br><br><br>

<h3>SOLUZIONE PROPOSTA</h3>
Dopo l'analisi appena effettuata proponiamo una possibile soluzione, che a nostro parere incorpora la maggior parte dei vantaggi: <br>
L'obiettivo &eacute quello di modellare il WASTE_SERVICE come controllore del sistema. Esso riceve dal SONAR il comando di stop/resume, in modo 
tale da poter memorizzare lo stato in cui trova il TROLLEY prima dello stop.<br>
Successivamente il WASTE_SERVICE invier&aacute il comando appena ricevuto dal SONAR al TROLLEY, il quale, 
se si trova in uno stato di movimento, dovr&aacute emettere l'evento alarm per notificare lo stop anche al pathexecutor.
Oltre al comando stop/resume, il WASTE_SERVICE dovr&aacute anche pilotare il comportamento del LED tramite 
l'invio del comando on/off/blink.<br>
Infine viene introdotta un'ulteriore request-response per gestire l'introduzione del nuovo stato "go_indoor" e il payload del comando resume che arriva TROLLEY 
conterr&aacute l'indicazione dello stato da cui ripartire.<br>


<h3> ARCHITETTURA LOGICA</h3>
La soluzione che quindi proponiamo presenta la seguente architettura logica:<br>
CODICE: <a href="../src/analisiProblema.qak">Contesto WASTE_SERVICE e TROLLEY</a><br>
 &ensp;&nbsp;&emsp;&emsp; &emsp;	<a href="../../raspberry/src/raspberry.qak">Contesto Raspberry</a><br><br><br>
TEST: <a href="../test/it/unibo/TestApplSprint2.java">Test WASTE_SERVICE</a><br>
&nbsp;&emsp;&ensp;&emsp; <a href="../../raspberry/test/it/unibo/LedTest.java">Test LED</a><br>
&nbsp;&emsp;&ensp;&emsp; Non &eacute necessario effettuare test sul SONAR in quanto si utilizza il software fornito dal committente.<br><br><br>
<img src="./img_Sprint2/modelloEseguibile.png" alt="RF2" width="90%" height="90%"><br><br>


</div>
 

<h2>Test plans</h2> 
<div class="remark">
In questo Sprint sono state realizzate due test unit per verificare il corretto funzionamento delle entit&aacute che 
compongono il sistema, in particolare:
<ul>
	<li><a href="../../raspberry/test/it/unibo/LedTest.java">Test LED</a>: in questo caso viene sfruttatto il fatto che
		il LED sia una risorsa COAP. Infatti viene introdotto un osservatore COAP che monitora lo stato del LED, sostanzialmente
		viene inviato un comando al LED e si verifica che lo stato in cui si trova sia quello corretto.</li>
	<li><a href="../test/it/unibo/TestApplSprint2.java">Test WASTE_SERVICE</a>: in questa test unit si verifica il corretto funzionamento del
		WASTE_SERVICE, che funge da controller del sistema. Vengono sfruttati due osservatori COAP per monitorare rispettivamente lo stato 
		del TROLLEY e del LED. Viene simulato un comando del SONAR di stop/resume e si va a verificare che le due entit&aacute si trovino
		nello stato atteso.</li>
</ul>
</div>

<h2>Project</h2> 
 


<h2>Testing</h2> 
 

<h2>Deployment</h2> 

 
<h2>Maintenance</h2> 
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br><br> 	
  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
Davide Filoni email: davide.filoni2@studio.unibo.it <br>
Fabio Scagliarini : fabio.scagliarini@studio.unibo.it <br>
Filippo Comastri : filippo.comastri2@studio.unibo.it <br>
<a href=https://github.com/studyMatesFIDAFA/WasteService>Link git </a>
<!-- <img src="./TemplateToFill_files/DavideFiloni.jpeg" alt="mbot" width="15%" height="15%"> -->
</div> 

</body></html>