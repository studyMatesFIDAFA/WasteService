<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0114)file:///C:/Users/Davide/Desktop/issLab2022/it.unibo.issLabStart/userDocs/Dispense/html/_static/templateToFill.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    

   
<title>Waste Service SPRINT 3</title></head>
    
<body>
<div id="top">
<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
<div class="remark">
Progetto finale del corso di studio Ingegneria dei sistemi software M, Laurea Magistrale Università di Bologna. (SPRINT 3)
</div>

<h2>Sprint 2 results</h2>
<div class="remark">
Di seguito &eacute riportato il risultato finale ottenuto al termine dello <a href="../../sprint2/userDocs/Sprint2.html">Sprint 2</a>:<br>
<img src="./img_Sprint3/sintesiFinale_Sprint2.png" alt="RF2" width="90%" height="90%"><br>
MODELLO: <a href="../../sprint2/src/analisiProblema.qak">Contesto WASTE_SERVICE e TROLLEY</a><br>
&emsp;&emsp;&emsp;&nbsp;&emsp;&emsp;<a href="../../sonarqak/src/sonar.qakt">Modello eseguibile SONAR</a>.<br>
&emsp;&emsp;&emsp;&emsp;&emsp;	<a href="../../ledqak/src/led.qak">Modello eseguibile LED</a>.<br><br><br><br>
TEST: <a href="../../sprint2/test/it/unibo/TestApplSprint2.java">Test WASTE_SERVICE</a><br>
&nbsp;&emsp;&ensp;&emsp; <a href="../../raspberry/test/it/unibo/LedTest.java">Test LED</a><br>
</div>
 
 
<h2>Requirements</h2>
<div class="remark">
Per la parte di requisiti si veda la <a href="../../sprint1/userDocs/Sprint1_v2.html#requisiti">sezione Requirement dello Sprint 1</a>

</div>

 

<h2>Requirement analysis</h2>
<div class="remark">
<h3>PUNTI APERTI:</h3>
<ul>
 <li>La GUI deve avere un particolare design?<br>No</li>
 <li>In che forma deve essere rappresentato lo stato e la posizione del TROLLEY?<br>Stato: HOME, STOPPED e MOVIMENTO<br>
 POSIZIONE: pu&oacute essere precisa (coordinate o mappa) oppure approssimativa (area in cui si trova).</li>
 <br><br>
Per le considerazioni fatte su Requisiti funzionali e Requisiti non funzionali si vedano
i paragrafi dedicati nello  <a href="../../sprint1/userDocs/Sprint1_v2.html#analisi_requisiti">Sprint 1</a><br><br>

<h3>COMPONENTI A DISPOSIZIONE</h3>
Viene fortinto il software esemplificativo per la realizzazione della <a href="https://github.com/anatali/issLab2022/tree/main/webRobot22">GUI</a>.<br>
<h3>PROBLEMATICHE RF3</h3>
In questo Sprint ci concentreremo solamente sul <a href="../../sprint1/userDocs/Sprint1_v2.html#RF3">RF3</a>.
<ul>
<li><h4>STATO TROLLEY, LED E BOX</h4>
La GUI deve monitorare lo stato di TROLLEY, LED e Box perci&oacute &eacute necessario analizzare come ottenere tali informazioni.</li>

<li><h4>RAPPRESENTAZIONE DELLA POSIZIONE DEL TROLLEY</h4>
La posizione del TROLLEY pu&oacute essere precisa, espressa mediante coordinate o mappa, oppure approssimativa, indicando l'area in cui si trova o in cui si sta dirigendo.</li>


<li><h4>RAPPRESENTAZIONE CENTRALIZZATA O DISTRIBUITA DELLO STATO</h4>
La GUI deve mostrare lo stato di TROLLEY, LED e Box, queste informazioni possono essere contenute da un'unica entit&aacute oppure essere distribuite tra le varie entit&aacute del sistema. </li>

</div>

<h2>Problem analysis</h2>
<div class="remark">
<h3> PROBLEMATICHE RF3 EVIDENZIATE DURANTE L'ANALISI DEI REQUISITI</h3>
<h4> STATO TROLLEY, LED E BOX </h4>
La GUI deve mostrare a video lo stato di TROLLEY, LED e Box oltre che la posizione del TROLLEY. Queste informazioni
possono essere ottenute con diverse forme di interazione. In particolare, escludendo le forme di comunicazioni point-to-point
(request-response e dispatch) in quanto non risultano particolarmente utili ed efficienti in questo caso specifico, vi sono due alternative: 
<ul>
	<li>EVENTI: in base alle considerazioni che verranno fatte nella problematica "RAPPRESENTAZIONE CENTRALIZZATA O DISTRIBUITA DELLO STATO"
		pu&oacute esserci un'entit&aacute o pi&uacute entit&aacute che possono emettere un evento ogni volta che si verifica
		una transizione di stato.</li>
	<li>OSSERVETORI COAP: visto che le entit&aacute a cui siamo interssati sono modellate come attori, sono anche risorse COAP. Quindi
		&eacute possibile associare ad ognuna di esse uno specifico osservatore COAP che verr&aacute notificato ogni volta che
		si verificher&aacute una transizione di stato.</li>
</ul>

<h5>CONCLUSIONI</h5>
L'osservabilit&aacute COAP &eacute una feature gi&aacute presente nel modello realizzato nello Sprint 2 e viene usata
in fase di testing, perci&oacute potrebbe essere utilizzata anche per questa funzionalit&aacute. <br>
In ogni caso, queste due soluzioni, non sono implementabili lato browser, quindi sar&aacute necessario realizzarle
lato server. Cos&iacute facendo, si dovr&aacute prevedere una comunicazione tra browser e server per condividere queste informazioni
che potrebbe essere realizzata, ad esempio, mediante l'ausilio delle web socket. <br>

<h4>RAPPRESENTAZIONE DELLA POSIZIONE DEL TROLLEY</h4>
Tra le informazioni che la GUI deve mostrare vi &eacute anche la posizione attuale del TROLLEY, sulla base del colloquio effettuato
con il committente si evince che ci possono essere due modi altrnativi di rappresentare questa informazione: 
<ul>
	<li>Posizione PRECISA: in questo caso vengnono utilizzate le coordinate oppure una mappa animata per indicare la posizione corrente del TROLLEY. 
		Sicuramente rappresenta una soluzione molto pi&uacute precisa ma richieder&aacute un tempo di implementazione maggiore.</li>
	<li>Posizone APPROSSIMATA: questa soluzione consiste nell'indicare l'area in cui si trova o in cui si sta dirigendo il TROLLEY.
		Dal punto di vista implementativo richiede meno tempo e l'informazione pu&oacute essere inferita dallo stato attuale del TROLLEY, ovvimanete
		risulta meno precisa rispetto alla soluzione precedente.</li>
</ul>

<h5>CONCLUSIONI</h5>
Non essendoci richieste specifiche dal committente, si lascia libert&aacute di scelta al progettista.<br>

<h4>RAPPRESENTAZIONE CENTRALIZZATA O DISTRIBUITA DELLO STATO </h4>
Le informazioni riguardanti lo stato di TROLLEY, LED e Box e la posizione del TROLLEY possono essere contenute in un'unica entit&aacute
oppure distribuite per l'intero sistema: 
<ul>
	<li>Soluzione CENTRALIZZATA: in questo caso sar&aacute presente un'unica entit&aacute responsabile di aggiornare e condividere
		le informazioni a cui la GUI &eacute interessata. In particolare in base alle scelte che verranno fatte per la problematica
		"STATO TROLLEY, LED E BOX" questa entit&aacute si dovr&aacute incaricare di notificare la GUI ogni volta che si verifica un
		cambiamento di stato per un'entit&aacute a cui siamo interessati.</li>
	<li>Soluzione DISTRIBUITA: questa soluzione consiste nel contenere le informazioni nelle varie entit&aacute che compongono il
		sistema. Nel caso si utilizzino gli eventi le due soluzioni non presentano grosse differenze, mentre in caso di impiego dell'osservabilit&aacute
		COAP sar&aacute necessario introdurre un'osservatore per ogni attore. Quest'ultima soluzione richiede l'utilizzo di pi&uacute
		risorse per&oacute riduce i compiti che il WASTE_SERVICE, che rappresenterebbe l'entit&aacute responsabile della gestione delle
		informazioni, deve effettuare.</li>
</ul>

<h5>CONCLUSIONI</h5>
Non essendoci richieste specifiche dal committente, si consiglia la seconda soluzione in quanto
distribuisce i compiti tra le varie entit&aacute del sistema invece che concentrarli in una sola. <br>

<h3>SOLUZIONE PROPOSTA</h3>
Dopo l'analisi appena effettuata proponiamo una possibile soluzione, che a nostro parere incorpora la maggior parte dei vantaggi: <br>
Avendo gi&aacute a disposizione la feature dell'osservabilit&aacute COAP si consiglia di sfruttarla anche per implementare questo requisito.
Inoltre si suggerisce di mantenere le informzioni distribuite nel sistema per ridurre i compiti del WASTE_SERVICE.
Ci&oacute pu&oacute essere fatto introducendo un Controller lato server nel quale saranno presenti tre osservatori COAP incaricati di monitorare
rispettivamente TROLLEY, WASTE_SERVICE e LED e di comunicare i cambiamenti, tramite web socket, al browser che si incaricher&aacute
di aggiornare la GUI.


<h3> ARCHITETTURA LOGICA</h3>
Gli osservatori COAP gi&aacute presenti vengono utilizzati lato server per monitorare le informazioni di interesse per la GUI,
in pi&uacute viene introdotto un ulteriore osservatore COAP per ottenere le capacit&aacute attuali del glass e del plastic box,
interfacciandosi con il WASTE_SERVICE.<br>
La soluzione che quindi proponiamo presenta la seguente architettura logica:<br>

<img src="./img_Sprint3/modelloEseguibile.png" alt="RF2" width="70%" height="70%"><br><br>

</div>
 
<!--
<h2>Test plans <a name="testPlan"></a></h2> 
<div class="remark">
In questo Sprint sono state realizzate due test unit per verificare il corretto funzionamento delle entit&aacute che 
compongono il sistema, in particolare:
<ul>
	<li><a href="../../raspberry/test/it/unibo/LedTest.java">Test LED</a>: in questo caso viene sfruttatto il fatto che
		il LED sia una risorsa COAP. Infatti viene introdotto un osservatore COAP che monitora lo stato del LED, sostanzialmente
		viene inviato un comando al LED e si verifica che lo stato in cui si trova sia quello corretto.</li>
	<li><a href="../test/it/unibo/TestApplSprint2.java">Test WASTE_SERVICE</a>: in questa test unit si verifica il corretto funzionamento del
		WASTE_SERVICE, che funge da controller del sistema. Vengono sfruttati due osservatori COAP per monitorare rispettivamente lo stato 
		del TROLLEY e del LED. Viene simulato un comando del SONAR di stop/resume e si va a verificare che le due entit&aacute si trovino
		nello stato atteso.</li>
</ul>
</div> -->

<h2>Project</h2> 
 <div class="remark">
 Abbiamo deciso di utilizzare Spring Boot come framework web mediante il cui realizzare la web GUI richiesta nei requisiti
 forniti dal committente.<br>
 Nel dettaglio &eacute necessario distinguere ci&oacute che &eacute situato lato server con ci&oacute che &eacute situato lato
 browser.<br><br>In particolare lato server troviamo:
 <ul>
	<li><a href="../src/main/java/unibo/WasteServiceStatusGUI/controllers/WasteController.java">WasteController</a>:
		rappresenta la componente principale lato server. Essa si incarica di gestire tutte le richieste provenienti 
		dal browser e di generare tutti gli osservatori COAP per monitorare le informazioni da mostrare all'utente
		e notificare la GUI in caso di cambiamenti in modo tale da effettuare le modifiche necessarie.</li>
	<li><a href="../src/main/java/unibo/WasteServiceStatusGUI/controllers">Altre classi ausiliarie</a>:
		il restante codice presente lato server viene utilizzato dal WasteController per instaurare le connessioni con il sistema.
		In particolare, per realizzare la comunicazione con LED, WASTE_SERVICE e TROLLEY viene utilizzato il protocollo COAP, inoltre
		viene utilizzato anche il protocollo TCP per poter inviare delle lod_req al WASTE_SERVICE.</li>
	<li><a href="../src/main/java/unibo/WasteServiceStatusGUI/WasteServiceStatusGuiApplication.java">WasteServiceStatusGuiApplication</a>:
		&eacute la componente che si occupa di avviare l'intera applicazione.</li>
 </ul><br>
 Lato browser, invece, vi sono:
 <ul>
	<li><a href="../src/main/resources/templates/WasteServiceStatusGuiAjax.html">WasteServiceStatusGui</a>:
		rappresenta l'interfaccia grafica dell'applicazione web.</li>
	<li><a href="../src/main/resources/static">Vari script JavaScript</a>: utilizzati per l'aggiornamento dinamico
		dell'interfaccia.</li>
 </ul>
 Nel dettaglio viene utilizzato il protocollo HTTP per comunicare con il server in due "forme" differenti:
 <ul>
	<li>Richiesta sincrona: tramite un form vengono inviate al server le informazioni (ip e porta) per instaurare le
		connessioni COAP con le entit&aacute a cui si &eacute interessati (LED, WASTE_SERVICE e TROLLEY).</li>
	<li>Ajax (richiesta asincrona): utilizzata per inviare una load_req al server e per evitare il ricaricamento della pagina in modo tale 
		da non perdere le informazioni da mostrare all'utente.</li>
 </ul><br>
 Per quanto riguarda la rappresentazione della posizione del TROLLEY abbiamo deciso di fornire un'informazione approssimata,
 indicando l'area in cui si trova o verso cui si sta dirigendo il TROLLEY.<br>
 Infine per quanto concerne la rappresentazione dello stato, si &eacute deciso di seguire il consiglio dell'analista e optare
 per una rappresentazione distribuita dello stato del sistema.
 </div>

<!--
<h2>Testing</h2> 
<div class="remark">
 I test utilizzati per verificare il corretto funzionamento del sistema sono quelli riportati nella sezione
 <a href="#testPlan">"Test plans"</a>
 </div> -->
 
<h2>Final summary</h2> 
<div class="remark">
Di seguito viene riportata l'architettura finale del sistema.<br>

<img src="./img_Sprint3/sintesiFinale.png" alt="RF2" width="90%" height="90%"><br><br>

</div>
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br><br> 	
  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
Davide Filoni email: davide.filoni2@studio.unibo.it <br>
Fabio Scagliarini : fabio.scagliarini@studio.unibo.it <br>
Filippo Comastri : filippo.comastri2@studio.unibo.it <br>
<a href="https://github.com/studyMatesFIDAFA/WasteService">Link git </a>
<!-- <img src="./TemplateToFill_files/DavideFiloni.jpeg" alt="mbot" width="15%" height="15%"> -->
</div> 

</body></html>